#include "Adriel/variable.hpp"
#include "LocalPlayer.h"
#include "UsedConvars.h"
#include "TickbaseExploits.h"
#include "Aimbot_imi.h"
#include "datamap.h"
#include "UsedConvars.h"
#include "Eventlog.h"
#include "buildserver_chars.h"
#include "INetchannelInfo.h"
#include "WeaponController.h"
#include "VMProtectDefs.h"
#include "CSGO_HX.h"
#include "Fakelag.h"

Tickbase_t g_Tickbase;
extern bool DisableCLC_Move;

void Tickbase_t::OnCreateMove()
{
	VMP_BEGINMUTILATION("TBOCM")

	auto& var = variable::get();

	if (var.ragebot.exploits.i_ticks_to_wait > MAX_USER_CMDS - 2)
		var.ragebot.exploits.i_ticks_to_wait = MAX_USER_CMDS - 2;

	if (g_ClientState->m_nDeltaTick == -1)
	{
		for (int i = 0; i < 150; ++i)
		{
			m_iCustomTickbase[i][0] = 0;
			m_iCustomTickbase[i][1] = 0;
			m_iCalculatedTickbase[i] = 0;
		}
	}

	LocalPlayer.ApplyTickbaseShift = LocalPlayer.CanShiftShot = LocalPlayer.WaitForTickbaseBeforeFiring = LocalPlayer.PredictionStateIsShifted = false;

	m_iMaxProcessTicks = MAX_USER_CMDS;
	int menu_desired_shift_amount = var.ragebot.exploits.i_ticks_to_wait;
	int desired_shift_amount = menu_desired_shift_amount;
	auto gamerules = GetGamerules();
	if (gamerules && gamerules->IsValveServer())
		desired_shift_amount = min(desired_shift_amount, MAX_USER_CMDS - 2);

	if (LocalPlayer.Config_IsFakelagging() || (LocalPlayer.Config_IsAntiaiming() && LocalPlayer.Config_IsDesyncing()))
	{
		int maxshift = (m_iMaxProcessTicks - 1) - g_Info.m_iNumCommandsToChoke;//var.ragebot.i_fakelag_ticks;//g_ClientState->chokedcommands;
		if (desired_shift_amount > maxshift)
			desired_shift_amount = maxshift;
	}

	++m_iTicksAllowedForProcessing;

#if 0
	if (m_iMaxProcessTicks && m_iTicksAllowedForProcessing > m_iMaxProcessTicks)
	{
		++m_iDummyCommandsToProcess;

		m_bEnableShiftPrinting = false; //only render shifts that were actually used
		//LocalPlayer.NetvarMutex.Lock();
		Interfaces::Prediction->Update(g_ClientState->m_nDeltaTick, g_ClientState->m_nDeltaTick > 0, g_ClientState->last_command_ack, g_ClientState->lastoutgoingcommand + g_ClientState->chokedcommands);
		//LocalPlayer.NetvarMutex.Unlock();
		m_bEnableShiftPrinting = true;

		--m_iTicksAllowedForProcessing;
		if (m_iTicksAllowedForProcessing > m_iMaxProcessTicks)
			m_iTicksAllowedForProcessing = m_iMaxProcessTicks;
	}
#endif

	int num_used_commands = g_ClientState->chokedcommands + 1;
	int num_unused_commands = MAX_USER_CMDS - num_used_commands;
	if (desired_shift_amount > num_unused_commands)
		desired_shift_amount = num_unused_commands;
	num_used_commands += desired_shift_amount;

	//now clamp it to the max processable ticks
	int num_used_commands_clamped = min(g_ClientState->chokedcommands + 1, m_iTicksAllowedForProcessing);
	int num_unused_commands_clamped = min(MAX_USER_CMDS, m_iTicksAllowedForProcessing) - num_used_commands_clamped;
	desired_shift_amount = menu_desired_shift_amount;
	if (gamerules && gamerules->IsValveServer())
		desired_shift_amount = min(desired_shift_amount, MAX_USER_CMDS - 2);

	if (desired_shift_amount > num_unused_commands_clamped)
		desired_shift_amount = num_unused_commands_clamped;
	num_used_commands_clamped += desired_shift_amount;

	m_iTotalCommandsToSend = num_used_commands_clamped;
	m_iNumFakeCommandsToSend = desired_shift_amount;

	m_bReadyToShiftTickbase = g_ClientState->m_nDeltaTick != -1 && 
		(m_iTicksAllowedForProcessing >= num_used_commands 
			|| (LocalPlayer.Entity->GetVelocity().Length() > 5.0f && m_iNumFakeCommandsToSend >= 4));
	m_bIncrementTicksAllowedForProcessing = false;
	m_iNumInvalidTicksSent = 0;

	CBaseCombatWeapon* CurrentWeapon = LocalPlayer.Entity->GetWeapon();

	if ((!var.ragebot.exploits.b_hide_record && !var.ragebot.exploits.b_hide_shots && !var.ragebot.exploits.b_multi_tap.get() && !var.ragebot.exploits.b_nasa_walk.get())
		|| !LocalPlayer.Entity || !CurrentWeapon || CurrentWeapon->GetItemDefinitionIndex() != LocalPlayer.CurrentWeaponItemDefinitionIndex
		|| CurrentWeapon->GetClipOne() == 0 || fabsf(Interfaces::Globals->curtime - CurrentWeapon->GetLastShotTime()) > 3.0f)
	{
		LocalPlayer.LastShotWasShifted = false;
		LocalPlayer.UseDoubleTapHitchance = false;
	}

	if (!var.ragebot.exploits.b_multi_tap.get())
		LocalPlayer.UseDoubleTapHitchance = false;

	m_iBackupTickbaseFirstCmd = m_iCustomTickbase[(CurrentUserCmd.cmd->command_number - g_ClientState->chokedcommands) % 150][0]; //save the first cmd tickbase in case we dont decide to shift

	//if (CurrentUserCmd.cmd->buttons & IN_ATTACK2 || CurrentUserCmd.cmd->buttons & IN_ZOOM)
	//	g_Tickbase.m_flDelayTickbaseShiftUntilThisTime = Interfaces::Globals->realtime + 0.5f;
	VMP_END
}

void Tickbase_t::OnCreateMoveFinished()
{
	if (LocalPlayer.ApplyTickbaseShift)
	{
		if (g_ClientState->chokedcommands != 0)
			m_iCustomTickbase[CurrentUserCmd.cmd->command_number % 150][0] = 0;

		//force the next tick to send so we can fix the tickbase the very command after shifting. 
		//if we choke after shifting then we don't know what the starting tickbase will be until we send another packet
		g_Info.SetForceSend(true);

		//calculate the first command tickbase for the next cmd since we shifted this tick
		int latencyticks = max(0, TIME_TO_TICKS(Interfaces::EngineClient->GetNetChannelInfo()->GetAvgLatency(FLOW_OUTGOING)));
		#ifdef UK_FIX
		int tickb = g_ClientState->m_ClockDriftMgr.m_nServerTick;
		#else
		int tickb = g_ClientState->m_nServerTick + latencyticks + 1;
		#endif
		int clockcorrect = TIME_TO_TICKS(0.03f); //sv_clockcorrectmsecs
		int	nIdealFinalTick = tickb + clockcorrect;
		nIdealFinalTick += 1; //because we are predicting 1 command in the future
		int nextslot = (CurrentUserCmd.cmd->command_number + 1) % 150;
		m_iCustomTickbase[nextslot][0] = nIdealFinalTick;
		m_iCustomTickbase[nextslot][1] = 1; //don't reset this command, recalculate the tickbase at the beginning of next createmove
#ifdef _DEBUG
		printf("predicted next cmd start curtime %f tickbase %i\npredicted next end frame curtime %f tickbase %i\n", TICKS_TO_TIME(nIdealFinalTick), nIdealFinalTick, TICKS_TO_TIME(nIdealFinalTick + 1), nIdealFinalTick + 1);
#endif
	}

	if (CurrentUserCmd.bSendPacket)
		m_bShiftedLastSendPacket = LocalPlayer.ApplyTickbaseShift;
}

extern bool ResetCLC_Move_Variables;

void Tickbase_t::OnPacketEnd(int commands_acknowledged)
{
	m_flLastServerPacketReceiveTime = QPCTime();
	m_iLastServerPacketReceiveTickcount = Interfaces::Globals->tickcount;

	if (commands_acknowledged <= 0)
		return;

	int m_nServerCommandsAcknowledged = Interfaces::Prediction->m_Split[0].m_nServerCommandsAcknowledged;
	m_nServerCommandsAcknowledged += commands_acknowledged;

	if (commands_acknowledged)
		m_iDummyCommandsToProcess = 0;

	if (Interfaces::EngineClient->IsInGame() && cl_predict.GetVar()->GetInt())
	{
		LocalPlayer.Get(&LocalPlayer);
		if (LocalPlayer.Entity)
		{
			//decrypts(0)
			typedescription_t *td = FindFlatFieldByName(XorStr("m_nTickbase"), LocalPlayer.Entity->GetPredDescMap());
			//encrypts(0)
			if (td)
			{
				void* slot = LocalPlayer.Entity->GetPredictedFrame(m_nServerCommandsAcknowledged - 1);

				if (slot)
				{
					int predicted_tickbase = *(int*)((byte *)slot + td->flatOffset[TD_OFFSET_PACKED]);
					int networked_tickbase = LocalPlayer.Entity->GetTickBase();

					if (networked_tickbase != predicted_tickbase)
					{
						int diff = predicted_tickbase - networked_tickbase;
#ifdef _DEBUG
						static ConVar* cl_showerror = Interfaces::Cvar->FindVar("cl_showerror");
						static ConVar* developer = Interfaces::Cvar->FindVar("developer");
						if (cl_showerror->GetInt() != 0 && developer->GetBool())
						{
							g_Eventlog.PrintToConsole(Color(255, 255, 255, 255), "Cheat int differs (m_nTickbase net %i pred %i) diff(%i)\n", networked_tickbase, predicted_tickbase, diff);
							printf("Cheat int differs (m_nTickbase net %i pred %i) diff(%i)\n", networked_tickbase, predicted_tickbase, diff);
						}
#endif

						if (diff != 0)
							LocalPlayer.m_bPredictionError = true;

						//if delta is positive, max processable ticks went up, otherwise it went down
#if 0
						if (abs(diff) != 0)
						{
							int maxprocessable = sv_maxusrcmdprocessticks.GetVar()->GetInt();
							float desiredrealtime = Interfaces::Globals->realtime + TICKS_TO_TIME(abs(diff) + g_ClientState->chokedcommands + 1)/* + Interfaces::EngineClient->GetNetChannelInfo()->GetAvgLatency(FLOW_OUTGOING)*/;
							if (m_flDelayTickbaseShiftUntilThisTime < desiredrealtime)
								m_flDelayTickbaseShiftUntilThisTime = desiredrealtime;
							LocalPlayer.LastShotWasShifted = false;
							//m_iTicksAllowedForProcessing = min(max(0, g.m_iTicksAllowedForProcessing + diff), maxprocessable);
						}
#endif

#if 0
						CUserCmd *lastcmd = nullptr;
						for (int i = g_ClientState->command_ack; i < g_ClientState->lastoutgoingcommand + g_ClientState->chokedcommands; ++i)
						{
							CUserCmd *cmd = GetUserCmd(0, i);
							if (!cmd)
								break;
							int slot = cmd->command_number % 150;
							
							/*
							if (lastcmd && m_iCustomTickbase[lastcmd->command_number % 150][0] != 0)
							{
								if (m_iCustomTickbase[slot][0] != 0)
								{
									if (abs(diff) > 2)
									{
										m_iCustomTickbase[slot][0] = 0;
										m_iCustomTickbase[slot][1] = 0;
									}
								}
							}
							else*/
							{
								if (m_iCustomTickbase[slot][0] != 0)
								{
									m_iCustomTickbase[slot][0] = 0;
									m_iCustomTickbase[slot][1] = 0;
								}
							}
							lastcmd = cmd;
						}
#endif

						m_bEnableShiftPrinting = false; //only render shifts that were actually used
						//LocalPlayer.NetvarMutex.Lock();
						//Interfaces::Prediction->Update(g_ClientState->m_ClockDriftMgr.m_nServerTick, g_ClientState->m_ClockDriftMgr.m_nServerTick > 0, g_ClientState->command_ack, g_ClientState->lastoutgoingcommand + g_ClientState->chokedcommands);
						//LocalPlayer.NetvarMutex.Unlock();
						m_bEnableShiftPrinting = true;
					}

				}
			}
		}
	}
}

int Tickbase_t::GetFakelagLimit()
{
	if (variable::get().ragebot.exploits.b_multi_tap.get())
		return 1;
	return 11;
}

//CBasePlayer::AdjustPlayerTimeBase
int Tickbase_t::CalculateFirstCmdTickbaseWhenShifted()
{
	VMP_BEGINMUTILATION("CFCTBWS")
	int maxprocessable = MAX_USER_CMDS;
	int clockcorrect = TIME_TO_TICKS(0.03f); //sv_clockcorrectmsecs
	int latencyticks = max(0, TIME_TO_TICKS(Interfaces::EngineClient->GetNetChannelInfo()->GetAvgLatency(FLOW_OUTGOING)));
	#ifdef UK_FIX
	int tickb = g_ClientState->m_ClockDriftMgr.m_nServerTick;
	#else
	int tickb = g_ClientState->m_nServerTick + latencyticks + 1;
	#endif

	int	nIdealFinalTick = tickb + clockcorrect;

	int simulation_ticks = m_iTotalCommandsToSend;

#if 1
	if (m_bShiftedLastSendPacket)
		return LocalPlayer.Entity->GetTickBase();

	return nIdealFinalTick - simulation_ticks + 1;
#else
	//this is fucked even though the logic is correct

	int current_tickbase = LocalPlayer.Entity->GetTickBase();
	int new_tickbase = current_tickbase;
	int nEstimatedFinalTick = current_tickbase + simulation_ticks;

	// If client gets ahead of this, we'll need to correct
	int	 too_fast_limit = nIdealFinalTick + clockcorrect;
	// If client falls behind this, we'll also need to correct
	int	 too_slow_limit = nIdealFinalTick - clockcorrect;

	if (nEstimatedFinalTick > too_fast_limit || nEstimatedFinalTick < too_slow_limit)
		new_tickbase = nIdealFinalTick - simulation_ticks + 1;
	else
	{
#if defined _DEBUG || defined INTERNAL_DEBUG
		AllocateConsole();
		printf("waiting to be able to actually shift\n");
#endif
		//new_tickbase = nIdealFinalTick - simulation_ticks + 1;
	}
	return new_tickbase;
#endif
	VMP_END
}

void Tickbase_t::RunExploits(CUserCmd *cmd)
{
	auto &var = variable::get();
	if (LocalPlayer.IsAllowedUntrusted()
		&& LocalPlayer.CurrentWeaponItemDefinitionIndex != WEAPON_REVOLVER
		&& LocalPlayer.Entity->GetWeapon()
		&& !LocalPlayer.IsFakeDucking
		&& !LocalPlayer.IsFakeLaggingOnPeek
		&& !LocalPlayer.IsTeleporting
		&& !LocalPlayer.WeaponWillFireBurstShotThisTick
		&& (var.ragebot.exploits.b_hide_shots || var.ragebot.exploits.b_hide_record || var.ragebot.exploits.b_multi_tap.get() || var.ragebot.exploits.b_nasa_walk.get()))
	{
		if (g_ClientState->chokedcommands == 0 && (CurrentUserCmd.IsUserCmdAndPlayerNotMoving()/*|| var.ragebot.exploits.b_nasa_walk.get()*/))
		{
			if (m_bForceNextTickToIncrementTicksAllowedForProcessing || 
				/*( !var.ragebot.exploits.b_hide_record && !var.ragebot.exploits.b_nasa_walk.get() && rand() % 50 == 0 && (!g_Ragebot.GetTarget() || fabsf(Interfaces::Globals->curtime - LocalPlayer.Entity->GetWeapon()->GetLastShotTime()) > 1.5f) )
				||*/ !m_bReadyToShiftTickbase)
			{
				LocalPlayer.WaitForTickbaseBeforeFiring = true;

				if (m_iNumInvalidTicksSent != 1 || var.ragebot.exploits.b_nasa_walk.get())
				{
					m_bIncrementTicksAllowedForProcessing = true;
					m_iNumInvalidTicksSent++;
					m_bForceNextTickToIncrementTicksAllowedForProcessing = false;
				}
				else
				{
					m_iNumInvalidTicksSent = 0;
					if (m_bReadyToShiftTickbase)
					{
						m_bForceNextTickToIncrementTicksAllowedForProcessing = true;
					}
				}
			}
		}

		if (m_bIncrementTicksAllowedForProcessing)
		{
			cmd->tick_count += 300;
			g_Info.SetForceSend(true);
			g_Info.SetShouldChoke(false);
			LocalPlayer.WaitForTickbaseBeforeFiring = true;
		}
		else if (LocalPlayer.Entity->GetAlive() && LocalPlayer.Entity->GetWeapon())
		{
			if (!m_bReadyToShiftTickbase && !var.ragebot.exploits.b_hide_record)
			{
				LocalPlayer.WaitForTickbaseBeforeFiring = CurrentUserCmd.IsUserCmdAndPlayerNotMoving();
			}
			else
			{
				if (Interfaces::Globals->realtime < m_flDelayTickbaseShiftUntilThisTime)
				{
					LocalPlayer.WaitForTickbaseBeforeFiring = true;
				}
				else
				{
					//When hiding records, 
					if (!var.ragebot.exploits.b_hide_record || m_iNumFakeCommandsToSend > 0)
					{
						//Can we already fire without shifting?
						bool _CanFireWithoutShifting = g_WeaponController.WeaponDidFire(CurrentUserCmd.cmd->buttons | IN_ATTACK);

						//Go ahead and shift the tickbase and predict it
						bool _DidShift = ShiftTickbaseBackwards(cmd);

						//Can we still fire after shifting tickbase backwards?
						bool _CanFireAfterShifting = g_WeaponController.WeaponDidFire(CurrentUserCmd.cmd->buttons | IN_ATTACK);

						LocalPlayer.CanShiftShot = _DidShift && _CanFireAfterShifting;

						if (var.ragebot.exploits.b_hide_record)
						{
							//always shift tickbase even if we can't fire when hiding record
							LocalPlayer.ApplyTickbaseShift = _DidShift;
							LocalPlayer.CanShiftShot = _DidShift;
						}
						else
						{
							if (!_DidShift || !_CanFireAfterShifting)
							{
								//Restore prediction to before tickbasing 
								if (_DidShift)
								{
									UndoShiftedPrediction();
								}

								//Don't allow the ragebot to fire if we can't shift, or if rapid fire is disabled (we want to hide shots always), or if the last shot was shifted
								//If the last shot was not shifted, we want to wait until we can double tap again
								LocalPlayer.WaitForTickbaseBeforeFiring = !_DidShift || !var.ragebot.exploits.b_multi_tap.get() || !LocalPlayer.LastShotWasShifted;
							}
						}
					}
				}
			}
		}
	}

	if (g_ClientState->chokedcommands == 0)
	{
		LocalPlayer.m_flFirstCommandLastInjuryTime = LocalPlayer.Entity->GetTimeOfLastInjury();
	}
}

//Returns true on success
bool Tickbase_t::ShiftTickbaseBackwards(CUserCmd* cmd)
{
	//Set the first command in this choke cycle to be predicted at the desired tickbase
	int _ShiftedTickbase = CalculateFirstCmdTickbaseWhenShifted();

	VMP_BEGINMUTILATION("STBBW")

	//If the tickbase was the same as the last one received from the server, we can't shift for some reason.
	if (_ShiftedTickbase == LocalPlayer.Entity->GetTickBase())
		return false;

	int _FirstCommandSlot = (cmd->command_number - g_ClientState->chokedcommands) % 150;

	m_iBackupTickbase = LocalPlayer.Entity->GetTickBase(); //store the current tickbase in case we need to restore prediction later if we did not decide to shift
	m_iBackupTickbaseFirstCmd = m_iCustomTickbase[_FirstCommandSlot][0]; //save the first cmd tickbase in case we dont decide to shift

	m_iCustomTickbase[_FirstCommandSlot][0] = _ShiftedTickbase; //let prediction know that the first command was shifted

	if (g_ClientState->chokedcommands != 0)
	{
		//Predict all the choked commands at the desired tickbase
		m_bEnableShiftPrinting = false; //only render shifts that were actually used
		//LocalPlayer.NetvarMutex.Lock();
		Interfaces::Prediction->Update(g_ClientState->m_nDeltaTick, g_ClientState->m_nDeltaTick > 0, g_ClientState->last_command_ack, g_ClientState->lastoutgoingcommand + g_ClientState->chokedcommands);
		//LocalPlayer.NetvarMutex.Unlock();
		m_bEnableShiftPrinting = true;
		Interfaces::Globals->curtime = TICKS_TO_TIME(LocalPlayer.Entity->GetTickBase());
	}
	else
	{
		//This is already the first command, we don't need to run prediction yet
		LocalPlayer.Entity->SetTickBase(_ShiftedTickbase);
		Interfaces::Globals->curtime = TICKS_TO_TIME(_ShiftedTickbase);
	}

	//current prediction state is shifted backwards
	LocalPlayer.PredictionStateIsShifted = true;

	return true;
	VMP_END
}

void Tickbase_t::UndoShiftedPrediction()
{
	//OutputDebugString("here\n");

	//VMP_BEGINMUTILATION("UNDOSFTP")
	//Restore prediction to before tickbasing 

	int _FirstCommandSlot = (CurrentUserCmd.cmd->command_number - g_ClientState->chokedcommands) % 150;

	m_iCustomTickbase[_FirstCommandSlot][0] = m_iBackupTickbaseFirstCmd;

	if (g_ClientState->chokedcommands != 0)
	{
		//Predict all the choked commands at the desired tickbase
		m_bEnableShiftPrinting = false; //only render shifts that were actually used
		LocalPlayer.NetvarMutex.Lock();
		Interfaces::Prediction->Update(g_ClientState->m_nDeltaTick, g_ClientState->m_nDeltaTick > 0, g_ClientState->last_command_ack, g_ClientState->lastoutgoingcommand + g_ClientState->chokedcommands);
		LocalPlayer.NetvarMutex.Unlock();
		m_bEnableShiftPrinting = true;
		Interfaces::Globals->curtime = TICKS_TO_TIME(LocalPlayer.Entity->GetTickBase());
	}
	else
	{
		//This is already the first command, we don't need to run prediction yet
		LocalPlayer.Entity->SetTickBase(m_iBackupTickbase);
		Interfaces::Globals->curtime = TICKS_TO_TIME(m_iBackupTickbase);
	}

	LocalPlayer.PredictionStateIsShifted = false; //current prediction state is no longer shifted
	//VMP_END
}

void Tickbase_t::SetCurrentCommandTickbase()
{
	int current_slot = CurrentUserCmd.cmd->command_number % 150;
	if (m_iCustomTickbase[current_slot][1])
	{
		//we are shifting time forward for this command, so set the tickbase to what we predicted it to be
		int target_tickbase = m_iCustomTickbase[current_slot][0];
		LocalPlayer.Entity->SetTickBase(target_tickbase);
	}
}

extern void SendEventsDatagram(INetChannel* netchan);

void Tickbase_t::FixEvents()
{
#if 0
	if (LocalPlayer.IsAllowedUntrusted())
	{
		if (CurrentUserCmd.bSendPacket)
		{
			LocalPlayer.m_UserCommandMutex.Lock();
			LocalPlayer.m_vecUserCommands.push_back(CurrentUserCmd.cmd->command_number);
			if (LocalPlayer.m_vecUserCommands.size() > 150)
				LocalPlayer.m_vecUserCommands.erase(LocalPlayer.m_vecUserCommands.begin());
			LocalPlayer.m_UserCommandMutex.Unlock();
		}
		else
		{
			//Stop fake lag from delaying events
			//FIXME: does this break the fake LATENCY event delay fix? test it please
			INetChannel* netchan = (INetChannel*)g_ClientState->m_pNetChannel;
			if (netchan && oSendDatagram )
			{
				int backup_chokeamount = netchan->m_nChokedPackets;
				//netchan->m_nChokedPackets = 0;
				DisableCLC_Move = true;
				//g_ClientState->m_pNetChannel->SendDatagram(nullptr);
				SendEventsDatagram(nullptr);
				DisableCLC_Move = false;
				//--netchan->m_nOutSequenceNr;

				//netchan->m_nChokedPackets = backup_chokeamount;
			}
		}
	}
#endif
}

void Tickbase_t::Reset()
{
	m_iMaxProcessTicks = 16;
	m_iTicksAllowedForProcessing = 0;
	m_iNumFakeCommandsToSend = 0;
	m_bReadyToShiftTickbase = false;
	m_bIncrementTicksAllowedForProcessing = false;
	m_iNumInvalidTicksSent = 0;
	m_bEnableShiftPrinting = true;
	m_bForceNextTickToIncrementTicksAllowedForProcessing = false;
	m_flLastServerPacketReceiveTime = QPCTime();
	for (int i = 0; i < 150; ++i)
	{
		m_iCustomTickbase[i][0] = 0;
		m_iCustomTickbase[i][1] = 0;
		m_iCalculatedTickbase[i] = 0;
	}
}