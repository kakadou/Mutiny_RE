#pragma once

class CUserCmd;

class Tickbase_t
{
private:
	int m_iNumInvalidTicksSent;
	bool m_bForceNextTickToIncrementTicksAllowedForProcessing;
public:
	int m_iMaxProcessTicks; //sv_maxusrcmdprocessticks
	int m_iDummyCommandsToProcess;
	int m_iTicksAllowedForProcessing;
	int m_iTotalCommandsToSend;
	int m_iNumFakeCommandsToSend;
	bool m_bReadyToShiftTickbase;
	bool m_bIncrementTicksAllowedForProcessing;
	bool m_bEnableShiftPrinting;
	bool m_bShiftedLastSendPacket;
	int m_iBackupTickbase;
	int m_iBackupTickbaseFirstCmd;
	float m_flDelayTickbaseShiftUntilThisTime;
	double m_flLastServerPacketReceiveTime;
	int m_iLastServerPacketReceiveTickcount;
	int m_iCustomTickbase[150][2]; //if not set to 0, prediction will set tickbase to this on that command number
	int m_iCalculatedTickbase[150]; //tickbase we calculated for this command, used for debugging purposes

	void OnCreateMove();
	void OnCreateMoveFinished();
	void OnPacketEnd(int commands_acknowledged);
	void RunExploits(CUserCmd* cmd);
	void UndoShiftedPrediction();
	void SetCurrentCommandTickbase();
	void FixEvents();
	int CalculateFirstCmdTickbaseWhenShifted();
	int GetFakelagLimit();
	void Reset();
	Tickbase_t() 
	{ 
		Reset(); 
		m_bShiftedLastSendPacket = false;
	}

private:
	bool ShiftTickbaseBackwards(CUserCmd* cmd);
};

extern Tickbase_t g_Tickbase;
